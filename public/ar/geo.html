<!doctype html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Geo AR — Drop-in Viewer</title>

  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.3.3/aframe/build/aframe-ar-nft.js"></script>

  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.6); color:#fff; font:14px system-ui;
      padding:8px 12px; border-radius:10px; z-index:10; text-align:center; }
    #hud small { opacity:.8; display:block; }
    #btns { margin-top:6px; display:flex; gap:6px; justify-content:center; flex-wrap:wrap; }
    button { padding:6px 10px; border:0; border-radius:8px; font-weight:700; cursor:pointer }
    #motionGate { position:fixed; inset:0; display:none; place-items:center; z-index:9999;
      background:rgba(0,0,0,.85); color:#fff; text-align:center; padding:24px; font:16px system-ui; }
    #motionGate button { margin-top:12px; }
  </style>
</head>
<body>
  <!-- iOS motion permission gate -->
  <div id="motionGate">
    <div>
      <div style="font-weight:700;font-size:18px;margin-bottom:6px">Enable motion & camera</div>
      <div>Tap allow to enable motion/orientation for AR on iPhone.</div>
      <button id="enableMotion">Enable</button>
    </div>
  </div>

  <div id="hud">
    <div id="status">Loading…</div>
    <small id="coords"></small>
    <div id="btns">
      <button id="bigger">Scale +</button>
      <button id="smaller">Scale −</button>
      <button id="reset">Reset</button>
    </div>
  </div>

  <a-scene
    vr-mode-ui="enabled:false"
    renderer="antialias:true; alpha:true;"
    embedded
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; trackingMethod: best;">

    <!-- GPS camera -->
    <a-camera gps-camera></a-camera>

    <!-- The GLB model (+ visibility state machine) -->
    <a-entity id="model"
      gps-entity-place="latitude:0; longitude:0;"
      scale="8 8 8"
      rotation="0 0 0"
      record-visibility="within:25; grace:300; fade:320; minVisible:700; cooldown:150; settlePulse:1.05; settleDelta:1.5"
      animation__spin="property: rotation; to: 0 360 0; loop: true; dur: 8000; autoplay: true">
    </a-entity>
  </a-scene>

  <script>
    const $ = sel => document.querySelector(sel);
    const params = new URLSearchParams(location.search);
    const toNum = v => (v==null ? NaN : Number(v));

    const lat = toNum(params.get('lat'));
    const lng = toNum(params.get('lng'));

    // Default GLB + decode any URL-encoded ?model=... from the pin page
    const modelParam = params.get('model');
    const modelUrl = modelParam ? decodeURIComponent(modelParam)
                                : 'https://recordcatcher.b-cdn.net/glb/Nderec.glb';

    const statusEl = $('#status');
    const coordsEl = $('#coords');
    const modelEl  = $('#model');

    // Validate coords
    if (isNaN(lat) || isNaN(lng)) {
      statusEl.textContent = 'Missing or invalid lat/lng in URL.';
    } else {
      coordsEl.textContent = `lat: ${lat.toFixed(6)}, lng: ${lng.toFixed(6)}`;
    }

    // Place model & load GLB
    modelEl.setAttribute('gps-entity-place', `latitude: ${lat}; longitude: ${lng};`);
    modelEl.setAttribute('gltf-model', `url(${modelUrl})`);

    // Diagnostics
    modelEl.addEventListener('model-loaded', () => {
      statusEl.textContent = 'Model loaded. Walk toward the target point.';
    });
    modelEl.addEventListener('model-error', (e) => {
      const d = e && e.detail ? e.detail : {};
      const msg = ['Model failed to load.', d.src ? `src: ${d.src}` : '', d.message ? `msg: ${d.message}` : '']
        .filter(Boolean).join(' ');
      statusEl.textContent = msg;
      console.log('model-error', d);
    });

    // GPS status
    window.addEventListener('gps-camera-origin-coord-set', () => {
      statusEl.textContent = 'Origin set. Rendering at target.';
    });

    // Scale controls
    let baseScale = 8;
    $('#bigger').onclick = () => {
      baseScale *= 1.25;
      modelEl.setAttribute('scale', `${baseScale} ${baseScale} ${baseScale}`);
    };
    $('#smaller').onclick = () => {
      baseScale = Math.max(0.5, baseScale / 1.25);
      modelEl.setAttribute('scale', `${baseScale} ${baseScale} ${baseScale}`);
    };
    $('#reset').onclick = () => {
      baseScale = 8;
      modelEl.setAttribute('scale', '8 8 8');
      modelEl.setAttribute('rotation', '0 0 0');
    };

    // iOS motion permission
    document.addEventListener('DOMContentLoaded', () => {
      statusEl.textContent = 'Allow camera, motion & location. If blank, reload and move phone.';
      const gate = document.getElementById('motionGate');
      const btn = document.getElementById('enableMotion');
      const needsIOSPermission =
        typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function';
      if (needsIOSPermission) {
        gate.style.display = 'grid';
        btn.onclick = async () => {
          try {
            const res = await DeviceMotionEvent.requestPermission();
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              try { await DeviceOrientationEvent.requestPermission(); } catch (_) {}
            }
            if (res === 'granted') gate.style.display = 'none';
          } catch (e) {
            console.warn('Motion permission error:', e);
          }
        };
      }
    });

    // --- Visibility State Machine (A-Frame component) ---
    AFRAME.registerComponent('record-visibility', {
      schema: {
        within: {type:'number', default:25},     // meters to consider "positive"
        grace: {type:'number', default:300},     // ms negative tolerance
        fade: {type:'number', default:320},      // ms fade in/out
        minVisible: {type:'number', default:700},// ms min visible time before honoring negative
        cooldown: {type:'number', default:150},  // ms ignore positives after fade-out
        settlePulse: {type:'number', default:1.05}, // scale pulse on reposition
        settleDelta: {type:'number', default:1.5}   // meters movement that triggers pulse
      },
      init() {
        this.state = 'HIDDEN';
        this.lastVisibleAt = 0;
        this.lastHideAt = 0;
        this.graceTimer = null;
        this.targetLL = {lat: lat, lng: lng};
        this.lastDistance = Infinity;
        this.lastWorldPos = new THREE.Vector3();
        this.fading = null;
        this.baseScale = this.el.object3D.scale.clone();

        // Prepare materials to allow opacity tweening
        this.el.addEventListener('model-loaded', () => {
          this.traverseMaterials_(m => { m.transparent = true; if (m.opacity == null) m.opacity = 1; });
          // start hidden
          this.setOpacity_(0);
          this.state = 'HIDDEN';
        });

        // Start GPS watch
        this.watchId = navigator.geolocation.watchPosition(
          pos => this.onGeo_(pos),
          err => console.warn('geo error', err),
          {enableHighAccuracy:true, maximumAge:1000, timeout:10000}
        );
      },
      remove() {
        if (this.watchId) navigator.geolocation.clearWatch(this.watchId);
        if (this.graceTimer) clearTimeout(this.graceTimer);
      },
      onGeo_(pos) {
        const {latitude, longitude, accuracy} = pos.coords;
        const d = this.haversine_(latitude, longitude, this.targetLL.lat, this.targetLL.lng);
        const positive = (d <= this.data.within) && (accuracy == null || accuracy <= 50);

        // Reposition pulse if the system moved the model notably (feels intentional)
        if (isFinite(this.lastDistance) && Math.abs(d - this.lastDistance) > this.data.settleDelta) {
          this.pulseScale_();
        }
        this.lastDistance = d;

        const now = performance.now();

        if (positive) {
          // handle cooldown
          if (now - this.lastHideAt < this.data.cooldown) return;
          if (this.state === 'HIDDEN' || this.state === 'FADING_OUT') {
            this.toAppearing_();
          } else if (this.state === 'GRACE') {
            // bounce back to visible without a fade
            this.toVisible_();
          }
        } else {
          if (this.state === 'VISIBLE') {
            // obey minVisible
            if (now - this.lastVisibleAt < this.data.minVisible) return;
            this.toGrace_();
          } else if (this.state === 'APPEARING') {
            // if we lose immediately during appear, go to grace → fade out if persists
            this.toGrace_();
          }
        }
      },
      // --- State transitions ---
      toAppearing_() {
        this.clearGrace_();
        this.state = 'APPEARING';
        this.fadeTo_(1, this.data.fade, () => this.toVisible_());
      },
      toVisible_() {
        this.clearGrace_();
        this.state = 'VISIBLE';
        this.lastVisibleAt = performance.now();
        this.setOpacity_(1);
      },
      toGrace_() {
        this.clearGrace_();
        this.state = 'GRACE';
        this.graceTimer = setTimeout(() => {
          if (this.state === 'GRACE') this.toFadingOut_();
        }, this.data.grace);
      },
      toFadingOut_() {
        this.clearGrace_();
        this.state = 'FADING_OUT';
        this.fadeTo_(0, this.data.fade, () => {
          this.state = 'HIDDEN';
          this.lastHideAt = performance.now();
        });
      },
      clearGrace_() {
        if (this.graceTimer) { clearTimeout(this.graceTimer); this.graceTimer = null; }
      },
      // --- Visual helpers ---
      traverseMaterials_(fn) {
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return;
        mesh.traverse(o => { if (o.isMesh && o.material) {
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.forEach(fn);
        }});
      },
      setOpacity_(val) {
        this.traverseMaterials_(m => { m.opacity = val; m.needsUpdate = true; });
      },
      fadeTo_(target, dur, onDone) {
        if (this.fading) cancelAnimationFrame(this.fading);
        const start = performance.now();
        let from;
        this.traverseMaterials_(m => { if (from == null) from = m.opacity; });
        const tick = (now) => {
          const t = Math.min(1, (now - start) / dur);
          const eased = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easeInOutQuad
          const val = from + (target - from) * eased;
          this.setOpacity_((val));
          if (t < 1) { this.fading = requestAnimationFrame(tick); }
          else { this.fading = null; onDone && onDone(); }
        };
        this.fading = requestAnimationFrame(tick);
      },
      pulseScale_() {
        const o3d = this.el.object3D;
        const base = this.baseScale;
        const up = this.data.settlePulse;
        const dur = 180;
        // animate up then back
        const start = performance.now();
        const step = (now) => {
          const t = Math.min(1, (now - start) / dur);
          const s = (t < 0.5)
            ? 1 + (up - 1) * (t / 0.5)          // up to peak
            : up - (up - 1) * ((t - 0.5) / 0.5);// back to 1
          o3d.scale.set(base.x * s, base.y * s, base.z * s);
          if (t < 1) requestAnimationFrame(step);
          else o3d.scale.copy(base);
        };
        requestAnimationFrame(step);
      },
      // --- Utils ---
      haversine_(lat1, lon1, lat2, lon2) {
        const R = 6371000; // m
        const toRad = x => x * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(a));
      }
    });
  </script>
</body>
</html>
