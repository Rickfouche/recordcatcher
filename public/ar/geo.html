<!doctype html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Geo AR — Drop-in Viewer</title>

  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.3.3/aframe/build/aframe-ar-nft.js"></script>

  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.6); color:#fff; font:14px system-ui;
      padding:8px 12px; border-radius:10px; z-index:10; text-align:center; }
    #hud small { opacity:.8; display:block; }
    #btns { margin-top:6px; display:flex; gap:6px; justify-content:center; flex-wrap:wrap; }
    button { padding:6px 10px; border:0; border-radius:8px; font-weight:700; cursor:pointer }
    #motionGate { position:fixed; inset:0; display:none; place-items:center; z-index:9999;
      background:rgba(0,0,0,.85); color:#fff; text-align:center; padding:24px; font:16px system-ui; }
    #motionGate button { margin-top:12px; }
  </style>
</head>
<body>
  <!-- iOS motion permission gate -->
  <div id="motionGate">
    <div>
      <div style="font-weight:700;font-size:18px;margin-bottom:6px">Enable motion & camera</div>
      <div>Tap allow to enable motion/orientation for AR on iPhone.</div>
      <button id="enableMotion">Enable</button>
    </div>
  </div>

  <div id="hud">
    <div id="status">Loading…</div>
    <small id="coords"></small>
    <div id="btns">
      <button id="bigger">Scale +</button>
      <button id="smaller">Scale −</button>
      <button id="reset">Reset</button>
    </div>
  </div>

  <a-scene
    vr-mode-ui="enabled:false"
    renderer="antialias:true; alpha:true;"
    embedded
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; trackingMethod: best;">

    <!-- GPS camera -->
    <a-camera gps-camera id="gpsCam"></a-camera>

    <!-- Wrapper handles appear/disappear and grounding -->
    <a-entity id="recordWrap"
      visible="false"
      scale="0.001 0.001 0.001"
      animation__appear="property: scale; to: 1 1 1; dur: 320; easing: easeOutQuad; startEvents: rc-appear"
      animation__disappear="property: scale; to: 0.001 0.001 0.001; dur: 300; easing: easeInQuad; startEvents: rc-disappear">

      <!-- soft shadow disc -->
      <a-circle rotation="-90 0 0" radius="0.6" position="0 0.01 0"
        material="color:#000; opacity:0.25"></a-circle>

      <!-- GLB model (initially positioned by GPS, then 'locked') -->
      <a-entity id="model"
        gps-entity-place="latitude:0; longitude:0;"
        scale="8 8 8"
        rotation="0 0 0"
        animation__spin="property: rotation; to: 0 360 0; loop: true; dur: 8000; autoplay: true">
      </a-entity>
    </a-entity>
  </a-scene>

  <script>
    const $ = sel => document.querySelector(sel);
    const params = new URLSearchParams(location.search);
    const toNum = v => (v==null ? NaN : Number(v));

    const lat = toNum(params.get('lat'));
    const lng = toNum(params.get('lng'));
    const modelParam = params.get('model');
    const modelUrl = modelParam ? decodeURIComponent(modelParam)
                                : 'https://recordcatcher.b-cdn.net/glb/Nderec.glb';

    const statusEl = $('#status');
    const coordsEl = $('#coords');
    const modelEl  = $('#model');
    const wrapEl   = $('#recordWrap');
    const camEl    = $('#gpsCam');

    if (isNaN(lat) || isNaN(lng)) {
      statusEl.textContent = 'Missing or invalid lat/lng in URL.';
    } else {
      coordsEl.textContent = `lat: ${lat.toFixed(6)}, lng: ${lng.toFixed(6)}`;
    }

    // Load model
    modelEl.setAttribute('gltf-model', `url(${modelUrl})`);
    modelEl.addEventListener('model-loaded', () => {
      statusEl.textContent = 'Model loaded. Walk toward the target point.';
      // ensure sub-materials can fade if you ever use opacity later
      const mesh = modelEl.getObject3D('mesh');
      if (mesh) mesh.traverse(o => {
        if (o.isMesh && o.material) {
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.forEach(m => { m.transparent = true; m.needsUpdate = true; });
        }
      });
    });
    modelEl.addEventListener('model-error', (e) => {
      const d = e && e.detail ? e.detail : {};
      const msg = ['Model failed to load.', d.src ? `src: ${d.src}` : '', d.message ? `msg: ${d.message}` : '']
        .filter(Boolean).join(' ');
      statusEl.textContent = msg;
      console.log('model-error', d);
    });

    // Place model at target GPS (AR.js will convert to world coords)
    modelEl.setAttribute('gps-entity-place', `latitude: ${lat}; longitude: ${lng};`);

    // Show coords origin set
    window.addEventListener('gps-camera-origin-coord-set', () => {
      statusEl.textContent = 'Origin set. Rendering at target.';
    });

    // Scale controls
    let baseScale = 8;
    $('#bigger').onclick = () => {
      baseScale *= 1.25;
      modelEl.setAttribute('scale', `${baseScale} ${baseScale} ${baseScale}`);
    };
    $('#smaller').onclick = () => {
      baseScale = Math.max(0.5, baseScale / 1.25);
      modelEl.setAttribute('scale', `${baseScale} ${baseScale} ${baseScale}`);
    };
    $('#reset').onclick = () => {
      baseScale = 8;
      modelEl.setAttribute('scale', '8 8 8');
      modelEl.setAttribute('rotation', '0 0 0');
    };

    // iOS motion permission
    document.addEventListener('DOMContentLoaded', () => {
      statusEl.textContent = 'Allow camera, motion & location. If blank, reload and move phone.';
      const gate = document.getElementById('motionGate');
      const btn = document.getElementById('enableMotion');
      const needsIOSPermission =
        typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function';
      if (needsIOSPermission) {
        gate.style.display = 'grid';
        btn.onclick = async () => {
          try {
            const res = await DeviceMotionEvent.requestPermission();
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              try { await DeviceOrientationEvent.requestPermission(); } catch (_) {}
            }
            if (res === 'granted') gate.style.display = 'none';
          } catch (e) {
            console.warn('Motion permission error:', e);
          }
        };
      }
    });

    // ---- Appear / Disappear based on proximity + Lock-on-first-fix ----
    const WITHIN_METERS = 25; // proximity window to show
    const ACC_OK = 60;        // acceptable GPS accuracy (m)
    let locked = false;       // once true, we remove gps-entity-place so it stops "following"
    let lastLockAttempt = 0;

    // Helper: great-circle distance
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // m
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    // Show/hide wrapper using scale anims
    function appearWrap() {
      if (!wrapEl.getAttribute('visible')) {
        wrapEl.setAttribute('visible', true);
        wrapEl.emit('rc-appear');
      }
    }
    function disappearWrap() {
      if (wrapEl.getAttribute('visible')) {
        wrapEl.emit('rc-disappear');
        setTimeout(() => wrapEl.setAttribute('visible', false), 300);
      }
    }

    // Try to lock the model's current world position (so it stops following GPS updates)
    function tryLockStatic() {
      if (locked) return;
      const o3d = modelEl.object3D;
      // Make sure we've been placed at least once by AR.js
      const pos = new THREE.Vector3();
      o3d.getWorldPosition(pos);
      // Convert to local (scene) if needed (model is direct child, so local==world here)
      modelEl.removeAttribute('gps-entity-place'); // stop AR.js from moving it
      modelEl.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
      locked = true;
      // tiny "settle" pulse on the wrapper so it feels intentional
      settlePulse();
    }

    function settlePulse() {
      const base = wrapEl.object3D.scale.clone();
      const up = 1.05;
      const dur = 180;
      const t0 = performance.now();
      function step(now) {
        const t = Math.min(1, (now - t0) / dur);
        const s = (t < 0.5)
          ? 1 + (up - 1) * (t / 0.5)
          : up - (up - 1) * ((t - 0.5) / 0.5);
        wrapEl.object3D.scale.set(base.x * s, base.y * s, base.z * s);
        if (t < 1) requestAnimationFrame(step);
        else wrapEl.object3D.scale.copy(base);
      }
      requestAnimationFrame(step);
    }

    // Watch GPS for proximity + lock logic
    const watchId = navigator.geolocation.watchPosition(
      (pos) => {
        const {latitude:clat, longitude:clng, accuracy} = pos.coords;
        const dist = haversine(clat, clng, lat, lng);
        const ok = dist <= WITHIN_METERS && (accuracy == null || accuracy <= ACC_OK);

        if (ok) appearWrap();
        else    disappearWrap();

        // Once we're close enough, lock position so it no longer "walks" with you
        const now = performance.now();
        if (ok && !locked && (now - lastLockAttempt > 500)) {
          tryLockStatic();
          lastLockAttempt = now;
        }
      },
      (err) => console.warn('geo error', err),
      { enableHighAccuracy:true, maximumAge:1000, timeout:10000 }
    );
  </script>
</body>
</html>
